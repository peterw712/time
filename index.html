<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Time Budget App (Carry-Over Enabled)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
      background: #111;
      color: #eee;
    }
    canvas {
      max-width: 400px;
      margin: 20px auto;
    }
    input, button, select {
      padding: 10px;
      margin: 5px;
      font-size: 1rem;
      color: #000;
    }
    #activityStats {
      max-width: 400px;
      margin: 20px auto;
      text-align: left;
    }
    #activityStats table {
      width: 100%;
      border-collapse: collapse;
    }
    #activityStats th, #activityStats td {
      padding: 5px;
      border-bottom: 1px solid #555;
    }
    #activityStats th {
      text-align: left;
    }
    .delete-btn {
      background: transparent;
      border: none;
      color: #f44336;
      cursor: pointer;
      font-size: 1rem;
    }
    .clickable {
      cursor: pointer;
      text-decoration: underline;
    }
    #monthlyControls {
      display: none;
    }
  </style>
</head>
<body>
  <h1>Time Budget (with Carry-Over)</h1>
  <div>
    <label><input type="radio" name="viewMode" id="dailyMode" checked onclick="setMode('daily')" /> Daily</label>
    <label><input type="radio" name="viewMode" id="monthlyMode" onclick="setMode('monthly')" /> Monthly</label>
  </div>
  <div id="dailyControls">
    <label for="datePicker">Select Date:</label>
    <input type="date" id="datePicker" />
  </div>
  <div id="monthlyControls">
    <label for="monthPicker">Select Month:</label>
    <input type="month" id="monthPicker" />
  </div>
  <div id="controls">
    <input type="text" id="activityName" placeholder="Enter activity" />
    <button onclick="startActivity()" id="startBtn">Start</button>
    <button onclick="stopActivity()" id="stopBtn">Stop</button>
  </div>
  <div>
    <label><input type="checkbox" id="toggleMode" onchange="toggleLabelMode()" /> Show Percentage of Period</label>
  </div>
  <canvas id="timeChart"></canvas>
  <div id="activityStats"></div>

  <script>
    const SECONDS_IN_DAY = 86400;
    const genericColors = [
      '#4caf50', '#2196f3', '#ff9800', '#e91e63', '#9c27b0',
      '#00bcd4', '#ffc107', '#795548', '#607d8b'
    ];

    let showPercent = false;
    let viewMode = 'daily'; // 'daily' or 'monthly'

    function setMode(mode) {
      viewMode = mode;
      document.getElementById('dailyControls').style.display = mode === 'daily' ? 'block' : 'none';
      document.getElementById('monthlyControls').style.display = mode === 'monthly' ? 'block' : 'none';
      updateControls();
      updateChart();
    }

    function toggleLabelMode() {
      showPercent = document.getElementById('toggleMode').checked;
      updateChart();
    }

    function getStartOfDayTimestamp(dateObj) {
      return new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate()).getTime();
    }

    function parseDateString(dateStr) {
      const [yyyy, mm, dd] = dateStr.split('-').map(Number);
      return new Date(yyyy, mm - 1, dd);
    }

    function parseMonthString(monthStr) {
      const [yyyy, mm] = monthStr.split('-').map(Number);
      return new Date(yyyy, mm - 1, 1);
    }

    function formatDateKey(dateObj) {
      const yyyy = dateObj.getFullYear();
      const mm = String(dateObj.getMonth() + 1).padStart(2, '0');
      const dd = String(dateObj.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }

    function formatSeconds(sec) {
      const hours = Math.floor(sec / 3600);
      const minutes = Math.floor((sec % 3600) / 60);
      const seconds = sec % 60;
      const hh = hours.toString().padStart(2, '0');
      const mm = minutes.toString().padStart(2, '0');
      const ss = seconds.toString().padStart(2, '0');
      return `${hh}:${mm}:${ss}`;
    }

    let activityLog = [];
    let currentActivity = null;
    let viewedDate = new Date();
    let lastCheckedDayKey = formatDateKey(new Date()); // track which day we last recognized

    const datePicker = document.getElementById('datePicker');
    const monthPicker = document.getElementById('monthPicker');
    const activityNameInput = document.getElementById('activityName');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const controlsDiv = document.getElementById('controls');

    const ctx = document.getElementById('timeChart').getContext('2d');
    const chart = new Chart(ctx, {
      type: 'doughnut',
      data: { labels: [], datasets: [{ data: [], backgroundColor: [], borderColor: '#eee', borderWidth: 1 }] },
      options: {
        responsive: true,
        plugins: {
          legend: { position: 'bottom' },
          tooltip: { callbacks: { label: context => context.label || '' } }
        },
        animation: false,
      }
    });

    function loadDateData(dateObj) {
      const keyLog = `activityLog-${formatDateKey(dateObj)}`;
      const savedLog = JSON.parse(localStorage.getItem(keyLog) || '[]');
      activityLog = savedLog.map(item => ({ name: item.name, start: item.start, end: item.end }));

      const todayKey = formatDateKey(new Date());
      if (viewMode === 'daily' && formatDateKey(dateObj) === todayKey) {
        const savedCurrent = JSON.parse(localStorage.getItem('currentActivity') || 'null');
        if (savedCurrent) {
          currentActivity = savedCurrent;
          activityNameInput.value = currentActivity.name;
        } else {
          currentActivity = null;
        }
      } else {
        currentActivity = null;
      }
    }

    function saveDateData(dateObj) {
      const keyLog = `activityLog-${formatDateKey(dateObj)}`;
      localStorage.setItem(keyLog, JSON.stringify(activityLog));

      const todayKey = formatDateKey(new Date());
      if (viewMode === 'daily' && formatDateKey(dateObj) === todayKey) {
        if (currentActivity) {
          localStorage.setItem('currentActivity', JSON.stringify(currentActivity));
        } else {
          localStorage.removeItem('currentActivity');
        }
      }
    }

    datePicker.addEventListener('change', () => {
      const selectedStr = datePicker.value;
      if (!selectedStr) return;
      const selectedDate = parseDateString(selectedStr);
      viewedDate = selectedDate;
      loadDateData(viewedDate);
      updateControls();
      updateChart();
    });

    monthPicker.addEventListener('change', () => {
      const selectedStr = monthPicker.value;
      if (!selectedStr) return;
      const selectedMonth = parseMonthString(selectedStr);
      viewedDate = selectedMonth;
      activityLog = [];
      currentActivity = null;
      updateControls();
      updateChart();
    });

    function updateControls() {
      if (viewMode === 'daily' && formatDateKey(viewedDate) === formatDateKey(new Date())) {
        controlsDiv.style.display = 'block';
      } else {
        controlsDiv.style.display = 'none';
      }
    }

    function stopCurrentActivity(atTimestamp = Date.now()) {
      if (!currentActivity) return;
      currentActivity.end = atTimestamp;
      activityLog.push(currentActivity);
      saveDateData(viewedDate);
      currentActivity = null;
    }

    function startActivity() {
      if (viewMode !== 'daily') return;
      if (formatDateKey(viewedDate) !== formatDateKey(new Date())) return;
      const name = activityNameInput.value.trim();
      if (!name) return;
      if (currentActivity && currentActivity.name === name) return;
      if (currentActivity) {
        stopCurrentActivity();
      }
      currentActivity = { name, start: Date.now() };
      activityNameInput.value = name;
      saveDateData(viewedDate);
      updateChart();
    }

    function stopActivity() {
      if (viewMode !== 'daily') return;
      if (!currentActivity) return;
      stopCurrentActivity();
      activityNameInput.value = currentActivity ? currentActivity.name : '';
      updateChart();
    }

    function selectActivity(encodedName) {
      const name = decodeURIComponent(encodedName);
      activityNameInput.value = name;
    }

    function deleteActivity(encodedName) {
      if (viewMode !== 'daily') return;
      const name = decodeURIComponent(encodedName);
      activityLog = activityLog.filter(a => a.name !== name);
      saveDateData(viewedDate);
      updateChart();
    }

    function getDaysInMonth(year, month) {
      return new Date(year, month + 1, 0).getDate();
    }

    function updateChart() {
      let labels = [];
      let dataArray = [];
      let backgroundColor = [];

      if (viewMode === 'daily') {
        const now = Date.now();
        const startOfDay = getStartOfDayTimestamp(viewedDate);
        const todayKey = formatDateKey(new Date());
        const isToday = formatDateKey(viewedDate) === todayKey;
        const totalElapsedSeconds = isToday
          ? Math.floor((now - startOfDay) / 1000)
          : SECONDS_IN_DAY;
        const elapsed = Math.min(totalElapsedSeconds, SECONDS_IN_DAY);

        const activityDurations = {};
        let productiveSeconds = 0;

        activityLog.forEach(a => {
          const start = Math.max(a.start, startOfDay);
          const end = isToday
            ? Math.min(a.end || now, now)
            : Math.min(a.end, startOfDay + SECONDS_IN_DAY * 1000);
          if (end > start) {
            const duration = Math.floor((end - start) / 1000);
            activityDurations[a.name] = (activityDurations[a.name] || 0) + duration;
            productiveSeconds += duration;
          }
        });

        if (isToday && currentActivity) {
          const liveDuration = Math.floor((now - currentActivity.start) / 1000);
          activityDurations[currentActivity.name] = (activityDurations[currentActivity.name] || 0) + liveDuration;
          productiveSeconds += liveDuration;
        }

        const unproductiveSeconds = Math.max(0, elapsed - productiveSeconds);
        const remainingSeconds = isToday ? Math.max(0, SECONDS_IN_DAY - elapsed) : 0;

        const baseLabels = Object.keys(activityDurations);
        const baseData = Object.values(activityDurations);

        baseLabels.forEach((name, idx) => {
          const seconds = baseData[idx];
          if (showPercent) {
            const pct = ((seconds / SECONDS_IN_DAY) * 100).toFixed(1);
            labels.push(`${name} (${pct}%)`);
          } else {
            labels.push(`${name} (${formatSeconds(seconds)})`);
          }
          dataArray.push(seconds);
        });

        if (unproductiveSeconds > 0) {
          if (showPercent) {
            const pctU = ((unproductiveSeconds / SECONDS_IN_DAY) * 100).toFixed(1);
            labels.push(`Unaccounted (${pctU}%)`);
          } else {
            labels.push(`Unaccounted (${formatSeconds(unproductiveSeconds)})`);
          }
          dataArray.push(unproductiveSeconds);
        }
        if (remainingSeconds > 0) {
          if (showPercent) {
            const pctR = ((remainingSeconds / SECONDS_IN_DAY) * 100).toFixed(1);
            labels.push(`Remaining (${pctR}%)`);
          } else {
            labels.push(`Remaining (${formatSeconds(remainingSeconds)})`);
          }
          dataArray.push(remainingSeconds);
        }

        backgroundColor = labels.map(label => {
          if (label.startsWith('Unaccounted')) return '#777';
          if (label.startsWith('Remaining')) return 'rgba(0, 0, 0, 0)';
          const name = label.split(' (')[0];
          const activityIndex = baseLabels.indexOf(name);
          return genericColors[activityIndex % genericColors.length];
        });

        updateActivityStats(activityDurations, elapsed, baseLabels);
      }
      else {  // monthly mode
        const year = viewedDate.getFullYear();
        const month = viewedDate.getMonth();
        const days = getDaysInMonth(year, month);
        const totalMonthSeconds = days * SECONDS_IN_DAY;
        const now = Date.now();
        const monthStart = new Date(year, month, 1).getTime();
        const isCurrentMonth = month === new Date().getMonth() && year === new Date().getFullYear();
        const elapsedMonthSeconds = isCurrentMonth
          ? Math.floor((now - monthStart) / 1000)
          : totalMonthSeconds;

        const activityDurations = {};
        let productiveSeconds = 0;

        for (let d = 1; d <= days; d++) {
          const dateObj = new Date(year, month, d);
          const keyLog = `activityLog-${formatDateKey(dateObj)}`;
          const savedLog = JSON.parse(localStorage.getItem(keyLog) || '[]');
          savedLog.forEach(a => {
            const start = a.start;
            const end = formatDateKey(dateObj) === formatDateKey(new Date())
              ? (a.end || now)
              : a.end;
            const dayStart = new Date(year, month, d).getTime();
            const dayEnd = dayStart + SECONDS_IN_DAY * 1000;
            const clampedStart = Math.max(start, dayStart);
            const clampedEnd = Math.min(end, dayEnd);
            if (clampedEnd > clampedStart) {
              const duration = Math.floor((clampedEnd - clampedStart) / 1000);
              activityDurations[a.name] = (activityDurations[a.name] || 0) + duration;
              productiveSeconds += duration;
            }
          });
        }

        if (isCurrentMonth && currentActivity) {
          const start = currentActivity.start;
          const duration = Math.floor((now - start) / 1000);
          activityDurations[currentActivity.name] = (activityDurations[currentActivity.name] || 0) + duration;
          productiveSeconds += duration;
        }

        const unproductiveSeconds = Math.max(0, elapsedMonthSeconds - productiveSeconds);
        const remainingSeconds = Math.max(0, totalMonthSeconds - elapsedMonthSeconds);

        const baseLabels = Object.keys(activityDurations);
        const baseData = Object.values(activityDurations);

        baseLabels.forEach((name, idx) => {
          const seconds = baseData[idx];
          if (showPercent) {
            const pct = ((seconds / totalMonthSeconds) * 100).toFixed(1);
            labels.push(`${name} (${pct}%)`);
          } else {
            labels.push(`${name} (${formatSeconds(seconds)})`);
          }
          dataArray.push(seconds);
        });

        if (unproductiveSeconds > 0) {
          if (showPercent) {
            const pctU = ((unproductiveSeconds / totalMonthSeconds) * 100).toFixed(1);
            labels.push(`Unaccounted (${pctU}%)`);
          } else {
            labels.push(`Unaccounted (${formatSeconds(unproductiveSeconds)})`);
          }
          dataArray.push(unproductiveSeconds);
        }
        if (remainingSeconds > 0) {
          if (showPercent) {
            const pctR = ((remainingSeconds / totalMonthSeconds) * 100).toFixed(1);
            labels.push(`Remaining (${pctR}%)`);
          } else {
            labels.push(`Remaining (${formatSeconds(remainingSeconds)})`);
          }
          dataArray.push(remainingSeconds);
        }

        backgroundColor = labels.map(label => {
          if (label.startsWith('Unaccounted')) return '#777';
          if (label.startsWith('Remaining')) return 'rgba(0, 0, 0, 0)';
          const name = label.split(' (')[0];
          const activityIndex = baseLabels.indexOf(name);
          return genericColors[activityIndex % genericColors.length];
        });

        updateActivityStats(activityDurations, isCurrentMonth ? elapsedMonthSeconds : totalMonthSeconds, baseLabels);
      }

      chart.data.labels = labels;
      chart.data.datasets[0].data = dataArray;
      chart.data.datasets[0].backgroundColor = backgroundColor;
      chart.update();
    }

    function updateActivityStats(durations, periodSeconds, baseLabels) {
      const statsDiv = document.getElementById('activityStats');
      let html;
      if (viewMode === 'daily') {
        html = '<table><tr><th>Activity</th><th>Time</th><th>% of Elapsed</th><th>Delete</th></tr>';
        const allLabels = Object.keys(durations);
        allLabels.forEach((name, idx) => {
          const seconds = durations[name];
          const pct = ((seconds / periodSeconds) * 100).toFixed(1);
          let color;
          if (name === 'Unaccounted') color = '#777';
          else {
            const activityIndex = baseLabels.indexOf(name);
            color = genericColors[activityIndex % genericColors.length];
          }
          html += `
            <tr>
              <td class="clickable" onclick="selectActivity('${encodeURIComponent(name)}')" style="color: ${color}">${name}</td>
              <td>${formatSeconds(seconds)}</td>
              <td>${pct}%</td>
              <td><button class="delete-btn" onclick="deleteActivity('${encodeURIComponent(name)}')">&#x2716;</button></td>
            </tr>`;
        });
        html += '</table>';
      } else {
        html = '<table><tr><th>Activity</th><th>Time</th><th>% of Elapsed</th></tr>';
        const allLabels = Object.keys(durations);
        allLabels.forEach((name, idx) => {
          const seconds = durations[name];
          const pct = ((seconds / periodSeconds) * 100).toFixed(1);
          let color;
          if (name === 'Unaccounted') color = '#777';
          else {
            const activityIndex = baseLabels.indexOf(name);
            color = genericColors[activityIndex % genericColors.length];
          }
          html += `
            <tr>
              <td style="color: ${color}">${name}</td>
              <td>${formatSeconds(seconds)}</td>
              <td>${pct}%</td>
            </tr>`;
        });
        html += '</table>';
      }
      statsDiv.innerHTML = html;
    }

    // ───────────────────────────────────────────────────────────────
    // Midnight rollover (carry-over version):
    // When we detect that “today” flipped to a new day:
    //  1) If there’s a running activity, first push a slice ending at midnight into yesterday’s log.
    //  2) Immediately re-start that same activity at midnight (carry-over).
    //  3) Advance viewedDate to today, update the datePicker, reload data, and keep currentActivity alive.
    // ───────────────────────────────────────────────────────────────
    setInterval(() => {
      const now = Date.now();
      const today = new Date();
      const todayKey = formatDateKey(today);
      const midnightTimestamp = getStartOfDayTimestamp(today); // 00:00 of today

      // If we've crossed into a new “today”
      if (todayKey !== lastCheckedDayKey && now >= midnightTimestamp) {
        // 1) If there was a saved “currentActivity” from yesterday, split it at midnight:
        const savedCurrent = JSON.parse(localStorage.getItem('currentActivity') || 'null');
        if (savedCurrent) {
          // a) Create a record for “yesterday” that ends exactly at midnight
          const yesterdayDate = new Date(midnightTimestamp - SECONDS_IN_DAY * 1000);
          const prevKey = `activityLog-${formatDateKey(yesterdayDate)}`;
          const prevLog = JSON.parse(localStorage.getItem(prevKey) || '[]');

          // push the slice [ savedCurrent.start → midnight ]
          prevLog.push({
            name: savedCurrent.name,
            start: savedCurrent.start,
            end: midnightTimestamp
          });
          localStorage.setItem(prevKey, JSON.stringify(prevLog));

          // b) Now carry over into today: set currentActivity to start at midnight
          currentActivity = {
            name: savedCurrent.name,
            start: midnightTimestamp
          };
          // Save the “today’s currentActivity” back to localStorage
          localStorage.setItem('currentActivity', JSON.stringify(currentActivity));
        }

        // 2) Advance viewedDate to today, update the datePicker, reload data
        viewedDate = new Date(midnightTimestamp);
        const todayISO = new Date(midnightTimestamp).toISOString().split('T')[0];
        datePicker.value = todayISO;
        loadDateData(viewedDate);
        updateControls();
        updateChart();

        lastCheckedDayKey = todayKey;
      }
    }, 60 * 1000); // check once per minute

    window.addEventListener('DOMContentLoaded', () => {
      const today = new Date();
      // Fix for local timezone offset:
      const offsetMinutes = today.getTimezoneOffset();
      const localMid = new Date(today.getTime() - offsetMinutes * 60000);
      const todayStr = localMid.toISOString().split('T')[0];
      const year = localMid.getFullYear();
      const month = String(localMid.getMonth() + 1).padStart(2, '0');
      const monthStr = `${year}-${month}`;

      datePicker.value = todayStr;
      monthPicker.value = monthStr;
      viewedDate = parseDateString(todayStr);
      loadDateData(viewedDate);
      updateControls();
      updateChart();
      setInterval(updateChart, 1000);
    });
  </script>
</body>
</html>
