<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Time Budget App with Firebase Auth</title>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
      background: #111;
      color: #eee;
    }
    canvas {
      max-width: 400px;
      margin: 20px auto;
    }
    input, button, select {
      padding: 10px;
      margin: 5px;
      font-size: 1rem;
      color: #000;
    }
    #activityStats {
      max-width: 400px;
      margin: 20px auto;
      text-align: left;
    }
    #activityStats table {
      width: 100%;
      border-collapse: collapse;
    }
    #activityStats th, #activityStats td {
      padding: 5px;
      border-bottom: 1px solid #555;
    }
    #activityStats th {
      text-align: left;
    }
    .delete-btn {
      background: transparent;
      border: none;
      color: #f44336;
      cursor: pointer;
      font-size: 1rem;
    }
    .clickable {
      cursor: pointer;
      text-decoration: underline;
    }
    #monthlyControls {
      display: none;
    }
    #loginContainer, #appContainer {
      max-width: 500px;
      margin: 0 auto;
    }
    #appContainer {
      display: none;
    }
    #logoutBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: #e91e63;
      color: #fff;
      border: none;
      padding: 8px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- ========== LOGIN / SIGNUP SCREEN ========== -->
  <div id="loginContainer">
    <h1>Login to Time Budget App</h1>
    <input type="email" id="loginEmail" placeholder="Email" /><br />
    <input type="password" id="loginPassword" placeholder="Password" /><br />
    <button onclick="loginUser()">Login</button>
    <button onclick="signupUser()">Sign Up</button>
  </div>

  <!-- ========== MAIN APP (HIDDEN UNTIL LOGGED IN) ========== -->
  <div id="appContainer">
    <button id="logoutBtn" onclick="logoutUser()">Logout</button>
    <h1>Time Budget</h1>

    <div>
      <label><input type="radio" name="viewMode" id="dailyMode" checked onclick="setMode('daily')" /> Daily</label>
      <label><input type="radio" name="viewMode" id="monthlyMode" onclick="setMode('monthly')" /> Monthly</label>
    </div>

    <div id="dailyControls">
      <label for="datePicker">Select Date:</label>
      <input type="date" id="datePicker" />
    </div>
    <div id="monthlyControls">
      <label for="monthPicker">Select Month:</label>
      <input type="month" id="monthPicker" />
    </div>

    <div id="controls">
      <input type="text" id="activityName" placeholder="Enter activity" />
      <button onclick="startActivity()" id="startBtn">Start</button>
      <button onclick="stopActivity()" id="stopBtn">Stop</button>
    </div>

    <div>
      <label><input type="checkbox" id="toggleMode" onchange="toggleLabelMode()" />
        Show Percentage of Period</label>
    </div>

    <canvas id="timeChart"></canvas>
    <div id="activityStats"></div>
  </div>

  <script>
    // ================================================
    // 0) FIREBASE CONFIGURATION
    // ================================================
    // Replace the following with your Firebase project's config object.
    const firebaseConfig = {
      apiKey: "AIzaSyCUkmGNiWZqtvbESF42gOc00CGTf2fJ3Ow",
      authDomain: "time-budget-f0f13.firebaseapp.com",
      projectId: "time-budget-f0f13",
      // storageBucket, messagingSenderId, appId, etc. (if needed)
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();

    // ================================================
    // 1) AUTHENTICATION LOGIC (Firebase-based)
    // ================================================
    function loginUser() {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      if (!email || !password) {
        alert('Please enter both email and password.');
        return;
      }
      auth.signInWithEmailAndPassword(email, password)
        .catch(err => {
          alert('Login failed: ' + err.message);
        });
    }

    function signupUser() {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      if (!email || !password) {
        alert('Please enter both email and password.');
        return;
      }
      auth.createUserWithEmailAndPassword(email, password)
        .catch(err => {
          alert('Sign-up failed: ' + err.message);
        });
    }

    function logoutUser() {
      auth.signOut();
    }

    function showApp() {
      document.getElementById('loginContainer').style.display = 'none';
      document.getElementById('appContainer').style.display = 'block';
      initializeApp();
    }

    function showLogin() {
      document.getElementById('loginContainer').style.display = 'block';
      document.getElementById('appContainer').style.display = 'none';
    }

    auth.onAuthStateChanged(user => {
      if (user) {
        showApp();
      } else {
        showLogin();
      }
    });

    // ================================================
    // 2) TIME BUDGET APP LOGIC
    // ================================================
    const SECONDS_IN_DAY = 86400;
    const genericColors = [
      '#4caf50', '#2196f3', '#ff9800', '#e91e63',
      '#9c27b0', '#00bcd4', '#ffc107', '#795548', '#607d8b'
    ];

    let showPercent = false;
    let viewMode = 'daily'; // 'daily' or 'monthly'

    function setMode(mode) {
      viewMode = mode;
      document.getElementById('dailyControls').style.display =
        mode === 'daily' ? 'block' : 'none';
      document.getElementById('monthlyControls').style.display =
        mode === 'monthly' ? 'block' : 'none';
      updateControls();
      updateChart();
    }

    function toggleLabelMode() {
      showPercent = document.getElementById('toggleMode').checked;
      updateChart();
    }

    function getStartOfDayTimestamp(dateObj) {
      return new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate()).getTime();
    }
    function parseDateString(dateStr) {
      const [yyyy, mm, dd] = dateStr.split('-').map(Number);
      return new Date(yyyy, mm - 1, dd);
    }
    function parseMonthString(monthStr) {
      const [yyyy, mm] = monthStr.split('-').map(Number);
      return new Date(yyyy, mm - 1, 1);
    }
    function formatDateKey(dateObj) {
      const yyyy = dateObj.getFullYear();
      const mm = String(dateObj.getMonth() + 1).padStart(2, '0');
      const dd = String(dateObj.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }
    function formatSeconds(sec) {
      const H = Math.floor(sec / 3600);
      const M = Math.floor((sec % 3600) / 60);
      const S = sec % 60;
      return `${String(H).padStart(2, '0')}:${String(M).padStart(2, '0')}:${String(S).padStart(2, '0')}`;
    }
    function getStorageKey(base) {
      const user = auth.currentUser;
      return `${user.uid}-${base}`;
    }

    let activityLog = [];
    let currentActivity = null;
    let viewedDate = new Date();
    let lastCheckedDayKey = formatDateKey(new Date());

    const datePicker = document.getElementById('datePicker');
    const monthPicker = document.getElementById('monthPicker');
    const activityNameInput = document.getElementById('activityName');
    const controlsDiv = document.getElementById('controls');

    // Chart variable (will be created in initializeApp)
    let chart = null;

    function loadDateData(dateObj) {
      const keyLog = getStorageKey(`activityLog-${formatDateKey(dateObj)}`);
      const savedLog = JSON.parse(localStorage.getItem(keyLog) || '[]');
      activityLog = savedLog.map(item => ({
        name: item.name,
        start: item.start,
        end: item.end
      }));

      const todayKey = formatDateKey(new Date());
      if (viewMode === 'daily' && formatDateKey(dateObj) === todayKey) {
        const savedCurrent = JSON.parse(
          localStorage.getItem(getStorageKey('currentActivity')) || 'null'
        );
        if (savedCurrent) {
          currentActivity = savedCurrent;
          activityNameInput.value = currentActivity.name;
        } else {
          currentActivity = null;
        }
      } else {
        currentActivity = null;
      }
    }

    function saveDateData(dateObj) {
      const keyLog = getStorageKey(`activityLog-${formatDateKey(dateObj)}`);
      localStorage.setItem(keyLog, JSON.stringify(activityLog));

      const todayKey = formatDateKey(new Date());
      if (viewMode === 'daily' && formatDateKey(dateObj) === todayKey) {
        if (currentActivity) {
          localStorage.setItem(
            getStorageKey('currentActivity'),
            JSON.stringify(currentActivity)
          );
        } else {
          localStorage.removeItem(getStorageKey('currentActivity'));
        }
      }
    }

    datePicker.addEventListener('change', () => {
      const sel = datePicker.value;
      if (!sel) return;
      viewedDate = parseDateString(sel);
      loadDateData(viewedDate);
      updateControls();
      updateChart();
    });

    monthPicker.addEventListener('change', () => {
      const sel = monthPicker.value;
      if (!sel) return;
      viewedDate = parseMonthString(sel);
      activityLog = [];
      currentActivity = null;
      updateControls();
      updateChart();
    });

    function updateControls() {
      if (
        viewMode === 'daily' &&
        formatDateKey(viewedDate) === formatDateKey(new Date())
      ) {
        controlsDiv.style.display = 'block';
      } else {
        controlsDiv.style.display = 'none';
      }
    }

    function stopCurrentActivity(atTimestamp = Date.now()) {
      if (!currentActivity) return;
      currentActivity.end = atTimestamp;
      activityLog.push(currentActivity);
      saveDateData(viewedDate);
      currentActivity = null;
    }

    function startActivity() {
      if (viewMode !== 'daily') return;
      if (formatDateKey(viewedDate) !== formatDateKey(new Date())) return;
      const name = activityNameInput.value.trim();
      if (!name) return;
      if (currentActivity && currentActivity.name === name) return;
      if (currentActivity) {
        stopCurrentActivity();
      }
      currentActivity = { name, start: Date.now() };
      activityNameInput.value = name;
      saveDateData(viewedDate);
      updateChart();
    }

    function stopActivity() {
      if (viewMode !== 'daily') return;
      if (!currentActivity) return;
      stopCurrentActivity();
      activityNameInput.value = '';
      updateChart();
    }

    function selectActivity(encodedName) {
      const name = decodeURIComponent(encodedName);
      activityNameInput.value = name;
    }

    function deleteActivity(encodedName) {
      if (viewMode !== 'daily') return;
      const name = decodeURIComponent(encodedName);
      activityLog = activityLog.filter(a => a.name !== name);
      saveDateData(viewedDate);
      updateChart();
    }

    function getDaysInMonth(year, month) {
      return new Date(year, month + 1, 0).getDate();
    }

    function updateChart() {
      const labels = [];
      const dataArray = [];
      const backgroundColor = [];

      if (viewMode === 'daily') {
        const now = Date.now();
        const startOfDay = getStartOfDayTimestamp(viewedDate);
        const todayKey = formatDateKey(new Date());
        const isToday = formatDateKey(viewedDate) === todayKey;
        const totalElapsedSeconds = isToday
          ? Math.floor((now - startOfDay) / 1000)
          : SECONDS_IN_DAY;
        const elapsed = Math.min(totalElapsedSeconds, SECONDS_IN_DAY);

        const activityDurations = {};
        let productiveSeconds = 0;

        activityLog.forEach(a => {
          const start = Math.max(a.start, startOfDay);
          const end = isToday
            ? Math.min(a.end || now, now)
            : Math.min(a.end, startOfDay + SECONDS_IN_DAY * 1000);
          if (end > start) {
            const duration = Math.floor((end - start) / 1000);
            activityDurations[a.name] = (activityDurations[a.name] || 0) + duration;
            productiveSeconds += duration;
          }
        });

        if (isToday && currentActivity) {
          const liveDuration = Math.floor((now - currentActivity.start) / 1000);
          activityDurations[currentActivity.name] =
            (activityDurations[currentActivity.name] || 0) + liveDuration;
          productiveSeconds += liveDuration;
        }

        const unproductiveSeconds = Math.max(0, elapsed - productiveSeconds);
        const remainingSeconds = isToday ? Math.max(0, SECONDS_IN_DAY - elapsed) : 0;

        const baseLabels = Object.keys(activityDurations);
        const baseData = Object.values(activityDurations);

        baseLabels.forEach((name, idx) => {
          const secs = baseData[idx];
          if (showPercent) {
            const pct = ((secs / SECONDS_IN_DAY) * 100).toFixed(1);
            labels.push(`${name} (${pct}%)`);
          } else {
            labels.push(`${name} (${formatSeconds(secs)})`);
          }
          dataArray.push(secs);
        });

        if (unproductiveSeconds > 0) {
          if (showPercent) {
            const pctU = ((unproductiveSeconds / SECONDS_IN_DAY) * 100).toFixed(1);
            labels.push(`Unaccounted (${pctU}%)`);
          } else {
            labels.push(`Unaccounted (${formatSeconds(unproductiveSeconds)})`);
          }
          dataArray.push(unproductiveSeconds);
        }
        if (remainingSeconds > 0) {
          if (showPercent) {
            const pctR = ((remainingSeconds / SECONDS_IN_DAY) * 100).toFixed(1);
            labels.push(`Remaining (${pctR}%)`);
          } else {
            labels.push(`Remaining (${formatSeconds(remainingSeconds)})`);
          }
          dataArray.push(remainingSeconds);
        }

        labels.forEach(label => {
          if (label.startsWith('Unaccounted')) {
            backgroundColor.push('#777');
          } else if (label.startsWith('Remaining')) {
            backgroundColor.push('rgba(0, 0, 0, 0)');
          } else {
            const name = label.split(' (')[0];
            const idx = baseLabels.indexOf(name);
            backgroundColor.push(genericColors[idx % genericColors.length]);
          }
        });

        updateActivityStats(activityDurations, elapsed, baseLabels);
      } else {
        const year = viewedDate.getFullYear();
        const month = viewedDate.getMonth();
        const days = getDaysInMonth(year, month);
        const totalMonthSeconds = days * SECONDS_IN_DAY;
        const now = Date.now();
        const monthStart = new Date(year, month, 1).getTime();
        const isCurrentMonth =
          month === new Date().getMonth() && year === new Date().getFullYear();
        const elapsedMonthSeconds = isCurrentMonth
          ? Math.floor((now - monthStart) / 1000)
          : totalMonthSeconds;

        const activityDurations = {};
        let productiveSeconds = 0;

        for (let d = 1; d <= days; d++) {
          const dateObj = new Date(year, month, d);
          const keyLog = getStorageKey(`activityLog-${formatDateKey(dateObj)}`);
          const savedLog = JSON.parse(localStorage.getItem(keyLog) || '[]');
          savedLog.forEach(a => {
            const start = a.start;
            const end =
              formatDateKey(dateObj) === formatDateKey(new Date())
                ? a.end || now
                : a.end;
            const dayStart = new Date(year, month, d).getTime();
            const dayEnd = dayStart + SECONDS_IN_DAY * 1000;
            const clampedStart = Math.max(start, dayStart);
            const clampedEnd = Math.min(end, dayEnd);
            if (clampedEnd > clampedStart) {
              const duration = Math.floor((clampedEnd - clampedStart) / 1000);
              activityDurations[a.name] = (activityDurations[a.name] || 0) + duration;
              productiveSeconds += duration;
            }
          });
        }

        if (isCurrentMonth && currentActivity) {
          const liveDur = Math.floor((now - currentActivity.start) / 1000);
          activityDurations[currentActivity.name] =
            (activityDurations[currentActivity.name] || 0) + liveDur;
          productiveSeconds += liveDur;
        }

        const unproductiveSeconds = Math.max(
          0,
          elapsedMonthSeconds - productiveSeconds
        );
        const remainingSeconds = Math.max(
          0,
          totalMonthSeconds - elapsedMonthSeconds
        );

        const baseLabels = Object.keys(activityDurations);
        const baseData = Object.values(activityDurations);

        baseLabels.forEach((name, idx) => {
          const secs = baseData[idx];
          if (showPercent) {
            const pct = ((secs / totalMonthSeconds) * 100).toFixed(1);
            labels.push(`${name} (${pct}%)`);
          } else {
            labels.push(`${name} (${formatSeconds(secs)})`);
          }
          dataArray.push(secs);
        });

        if (unproductiveSeconds > 0) {
          if (showPercent) {
            const pctU = ((unproductiveSeconds / totalMonthSeconds) * 100).toFixed(1);
            labels.push(`Unaccounted (${pctU}%)`);
          } else {
            labels.push(`Unaccounted (${formatSeconds(unproductiveSeconds)})`);
          }
          dataArray.push(unproductiveSeconds);
        }
        if (remainingSeconds > 0) {
          if (showPercent) {
            const pctR = ((remainingSeconds / totalMonthSeconds) * 100).toFixed(1);
            labels.push(`Remaining (${pctR}%)`);
          } else {
            labels.push(`Remaining (${formatSeconds(remainingSeconds)})`);
          }
          dataArray.push(remainingSeconds);
        }

        labels.forEach(label => {
          if (label.startsWith('Unaccounted')) {
            backgroundColor.push('#777');
          } else if (label.startsWith('Remaining')) {
            backgroundColor.push('rgba(0, 0, 0, 0)');
          } else {
            const name = label.split(' (')[0];
            const idx = baseLabels.indexOf(name);
            backgroundColor.push(genericColors[idx % genericColors.length]);
          }
        });

        updateActivityStats(
          activityDurations,
          isCurrentMonth ? elapsedMonthSeconds : totalMonthSeconds,
          baseLabels
        );
      }

      if (chart) {
        chart.data.labels = labels;
        chart.data.datasets[0].data = dataArray;
        chart.data.datasets[0].backgroundColor = backgroundColor;
        chart.update();
      }
    }

    function updateActivityStats(durations, periodSeconds, baseLabels) {
      const statsDiv = document.getElementById('activityStats');
      let html;

      if (viewMode === 'daily') {
        html = '<table><tr><th>Activity</th><th>Time</th><th>% of Elapsed</th><th>Delete</th></tr>';
        const allLabels = Object.keys(durations);
        allLabels.forEach((name, idx) => {
          const secs = durations[name];
          const pct = ((secs / periodSeconds) * 100).toFixed(1);
          let color;
          if (name === 'Unaccounted') color = '#777';
          else {
            const ai = baseLabels.indexOf(name);
            color = genericColors[ai % genericColors.length];
          }
          html += `
            <tr>
              <td class="clickable" onclick="selectActivity('${encodeURIComponent(name)}')" style="color: ${color}">${name}</td>
              <td>${formatSeconds(secs)}</td>
              <td>${pct}%</td>
              <td><button class="delete-btn" onclick="deleteActivity('${encodeURIComponent(name)}')">&#x2716;</button></td>
            </tr>`;
        });
        html += '</table>';
      } else {
        html = '<table><tr><th>Activity</th><th>Time</th><th>% of Elapsed</th></tr>';
        const allLabels = Object.keys(durations);
        allLabels.forEach((name, idx) => {
          const secs = durations[name];
          const pct = ((secs / periodSeconds) * 100).toFixed(1);
          let color;
          if (name === 'Unaccounted') color = '#777';
          else {
            const ai = baseLabels.indexOf(name);
            color = genericColors[ai % genericColors.length];
          }
          html += `
            <tr>
              <td style="color: ${color}">${name}</td>
              <td>${formatSeconds(secs)}</td>
              <td>${pct}%</td>
            </tr>`;
        });
        html += '</table>';
      }

      statsDiv.innerHTML = html;
    }

    // ================================================
    // 3) MIDNIGHT ROLLOVER (CARRY-OVER LOGIC)
    // ================================================
    setInterval(() => {
      const now = Date.now();
      const today = new Date();
      const todayKey = formatDateKey(today);
      const midnightTimestamp = getStartOfDayTimestamp(today); // 00:00 today

      if (todayKey !== lastCheckedDayKey && now >= midnightTimestamp) {
        const savedCurrent = JSON.parse(
          localStorage.getItem(getStorageKey('currentActivity')) || 'null'
        );
        if (savedCurrent) {
          const yDay = new Date(midnightTimestamp - SECONDS_IN_DAY * 1000);
          const prevKey = getStorageKey(`activityLog-${formatDateKey(yDay)}`);
          const prevLog = JSON.parse(localStorage.getItem(prevKey) || '[]');
          prevLog.push({
            name: savedCurrent.name,
            start: savedCurrent.start,
            end: midnightTimestamp
          });
          localStorage.setItem(prevKey, JSON.stringify(prevLog));

          currentActivity = { name: savedCurrent.name, start: midnightTimestamp };
          localStorage.setItem(
            getStorageKey('currentActivity'),
            JSON.stringify(currentActivity)
          );
        }

        viewedDate = new Date(midnightTimestamp);
        const todayISO = new Date(midnightTimestamp).toISOString().split('T')[0];
        datePicker.value = todayISO;
        loadDateData(viewedDate);
        updateControls();
        updateChart();

        lastCheckedDayKey = todayKey;
      }
    }, 60 * 1000);

    // ================================================
    // 4) INITIALIZE ON PAGE LOAD
    // ================================================
    function initializeApp() {
      // Create the chart only when app is shown:
      const ctx = document.getElementById('timeChart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'doughnut',
        data: { labels: [], datasets: [{ data: [], backgroundColor: [], borderColor: '#eee', borderWidth: 1 }] },
        options: {
          responsive: true,
          plugins: {
            legend: { position: 'bottom' },
            tooltip: { callbacks: { label: ctx => ctx.label || '' } }
          },
          animation: false,
        }
      });

      const today = new Date();
      const offsetMinutes = today.getTimezoneOffset();
      const localMid = new Date(today.getTime() - offsetMinutes * 60000);
      const todayStr = localMid.toISOString().split('T')[0];
      const year = localMid.getFullYear();
      const month = String(localMid.getMonth() + 1).padStart(2, '0');
      const monthStr = `${year}-${month}`;

      datePicker.value = todayStr;
      monthPicker.value = monthStr;
      viewedDate = parseDateString(todayStr);
      loadDateData(viewedDate);
      updateControls();
      updateChart();
      setInterval(updateChart, 1000);
    }
  </script>
</body>
</html>
