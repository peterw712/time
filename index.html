<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Time Budget App (Firestore Sync - Real-Time)</title>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
      background: #111;
      color: #eee;
    }
    canvas {
      max-width: 400px;
      margin: 20px auto;
    }
    input, button, select {
      padding: 10px;
      margin: 5px;
      font-size: 1rem;
      color: #000;
    }
    #activityStats {
      max-width: 400px;
      margin: 20px auto;
      text-align: left;
    }
    #activityStats table {
      width: 100%;
      border-collapse: collapse;
    }
    #activityStats th, #activityStats td {
      padding: 5px;
      border-bottom: 1px solid #555;
    }
    #activityStats th {
      text-align: left;
    }
    .delete-btn {
      background: transparent;
      border: none;
      color: #f44336;
      cursor: pointer;
      font-size: 1rem;
    }
    .clickable {
      cursor: pointer;
      text-decoration: underline;
    }
    #monthlyControls {
      display: none;
    }
    #loginContainer, #appContainer {
      max-width: 500px;
      margin: 0 auto;
    }
    #appContainer {
      display: none;
    }
    #logoutBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: #e91e63;
      color: #fff;
      border: none;
      padding: 8px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- ========== LOGIN / SIGNUP SCREEN ========== -->
  <div id="loginContainer">
    <h1>Login to Time Budget App</h1>
    <input type="email" id="loginEmail" placeholder="Email" /><br />
    <input type="password" id="loginPassword" placeholder="Password" /><br />
    <button onclick="loginUser()">Login</button>
    <button onclick="signupUser()">Sign Up</button>
  </div>

  <!-- ========== MAIN APP (HIDDEN UNTIL LOGGED IN) ========== -->
  <div id="appContainer">
    <button id="logoutBtn" onclick="logoutUser()">Logout</button>
    <h1>Time Budget</h1>

    <div>
      <label>
        <input type="radio" name="viewMode" id="dailyMode" checked onclick="setMode('daily')" />
        Daily
      </label>
      <label>
        <input type="radio" name="viewMode" id="monthlyMode" onclick="setMode('monthly')" />
        Monthly
      </label>
    </div>

    <div id="dailyControls">
      <label for="datePicker">Select Date:</label>
      <input type="date" id="datePicker" />
    </div>
    <div id="monthlyControls">
      <label for="monthPicker">Select Month:</label>
      <input type="month" id="monthPicker" />
    </div>

    <div id="controls">
      <input type="text" id="activityName" placeholder="Enter activity" />
      <button onclick="startActivity()" id="startBtn">Start</button>
      <button onclick="stopActivity()" id="stopBtn">Stop</button>
    </div>

    <div>
      <label>
        <input type="checkbox" id="toggleMode" onchange="toggleLabelMode()" />
        Show Percentage of Period
      </label>
    </div>

    <canvas id="timeChart"></canvas>
    <div id="activityStats"></div>
  </div>

  <script>
    // ================================================
    // 0) FIREBASE CONFIGURATION
    // ================================================
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
      projectId: "YOUR_PROJECT_ID",
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // ================================================
    // 1) AUTHENTICATION LOGIC
    // ================================================
    function loginUser() {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      if (!email || !password) {
        alert('Please enter both email and password.');
        return;
      }
      auth.signInWithEmailAndPassword(email, password)
        .catch(err => alert('Login failed: ' + err.message));
    }

    function signupUser() {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      if (!email || !password) {
        alert('Please enter both email and password.');
        return;
      }
      auth.createUserWithEmailAndPassword(email, password)
        .catch(err => alert('Sign-up failed: ' + err.message));
    }

    function logoutUser() {
      auth.signOut();
      detachListeners();
    }

    function showApp() {
      document.getElementById('loginContainer').style.display = 'none';
      document.getElementById('appContainer').style.display = 'block';
      initializeApp();
    }

    function showLogin() {
      document.getElementById('loginContainer').style.display = 'block';
      document.getElementById('appContainer').style.display = 'none';
    }

    auth.onAuthStateChanged(user => {
      if (user) showApp();
      else showLogin();
    });

    // ================================================
    // 2) FIRESTORE HELPERS
    // ================================================
    function getUserBasePath() {
      const user = auth.currentUser;
      if (!user) throw new Error("No authenticated user");
      return `users/${user.uid}`;
    }

    async function saveToFirestore(docPath, dataObj) {
      try { await db.doc(`${getUserBasePath()}/${docPath}`).set(dataObj); }
      catch (e) { console.error("Firestore save error:", e); }
    }

    async function loadFromFirestore(docPath) {
      try {
        const doc = await db.doc(`${getUserBasePath()}/${docPath}`).get();
        return doc.exists ? doc.data() : null;
      } catch (e) {
        console.error("Firestore load error:", e);
        return null;
      }
    }

    let unsubscribeLog = null;
    let unsubscribeMeta = null;

    function detachListeners() {
      if (unsubscribeLog) { unsubscribeLog(); unsubscribeLog = null; }
      if (unsubscribeMeta) { unsubscribeMeta(); unsubscribeMeta = null; }
    }

    function setupListenersForDate(dateObj) {
      const dateKey = formatDateKey(dateObj);
      const todayKey = formatDateKey(new Date());
      if (dateKey !== todayKey) return;
      setupListenersForCurrentDay();
    }

    // ================================================
    // 3) TIME BUDGET APP LOGIC
    // ================================================
    const SECONDS_IN_DAY = 86400;
    const genericColors = [
      '#4caf50', '#2196f3', '#ff9800', '#e91e63',
      '#9c27b0', '#00bcd4', '#ffc107', '#795548', '#607d8b'
    ];

    let showPercent = false;
    let viewMode = 'daily';

    function setMode(mode) {
      viewMode = mode;
      document.getElementById('dailyControls').style.display =
        mode === 'daily' ? 'block' : 'none';
      document.getElementById('monthlyControls').style.display =
        mode === 'monthly' ? 'block' : 'none';
      updateControls();
      updateChart();
      if (mode === 'daily') setupListenersForDate(viewedDate);
      else setupListenersForCurrentDay();
    }

    function toggleLabelMode() {
      showPercent = document.getElementById('toggleMode').checked;
      updateChart();
    }

    function getStartOfDayTimestamp(dateObj) {
      return new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate()).getTime();
    }
    function parseDateString(dateStr) {
      const [yyyy, mm, dd] = dateStr.split('-').map(Number);
      return new Date(yyyy, mm - 1, dd);
    }
    function parseMonthString(monthStr) {
      const [yyyy, mm] = monthStr.split('-').map(Number);
      return new Date(yyyy, mm - 1, 1);
    }
    function formatDateKey(dateObj) {
      const yyyy = dateObj.getFullYear();
      const mm = String(dateObj.getMonth() + 1).padStart(2, '0');
      const dd = String(dateObj.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }
    function formatSeconds(sec) {
      const H = Math.floor(sec / 3600);
      const M = Math.floor((sec % 3600) / 60);
      const S = sec % 60;
      return `${String(H).padStart(2, '0')}:${String(M).padStart(2, '0')}:${String(S).padStart(2, '0')}`;
    }

    let activityLog = [];
    let currentActivity = null;
    let viewedDate = new Date();
    let lastCheckedDayKey = formatDateKey(new Date());

    const datePicker = document.getElementById('datePicker');
    const monthPicker = document.getElementById('monthPicker');
    const activityNameInput = document.getElementById('activityName');
    const controlsDiv = document.getElementById('controls');

    let chart = null;

    async function loadDateData(dateObj) {
      const dateKey = formatDateKey(dateObj);
      const logDoc = await loadFromFirestore(`logs/${dateKey}`);
      activityLog = logDoc?.log || [];

      const todayKey = formatDateKey(new Date());
      if (viewMode === 'daily' && dateKey === todayKey) {
        const metaDoc = await loadFromFirestore(`meta/currentActivity`);
        currentActivity = metaDoc?.currentActivity || null;
        activityNameInput.value = currentActivity?.name || '';
      } else {
        currentActivity = null;
      }
    }

    async function saveDateData(dateObj) {
      const dateKey = formatDateKey(dateObj);
      await saveToFirestore(`logs/${dateKey}`, { log: activityLog });

      const todayKey = formatDateKey(new Date());
      if (viewMode === 'daily' && dateKey === todayKey) {
        if (currentActivity) {
          await saveToFirestore(`meta/currentActivity`, { currentActivity });
        } else {
          await saveToFirestore(`meta/currentActivity`, { currentActivity: null });
        }
      }
    }

    datePicker.addEventListener('change', async () => {
      const sel = datePicker.value;
      if (!sel) return;
      viewedDate = parseDateString(sel);
      detachListeners();
      await loadDateData(viewedDate);
      setupListenersForDate(viewedDate);
      updateControls();
      updateChart();
    });

    monthPicker.addEventListener('change', async () => {
      const sel = monthPicker.value;
      if (!sel) return;
      viewedDate = parseMonthString(sel);
      detachListeners();
      activityLog = [];
      currentActivity = null;
      updateControls();
      updateChart();
      setupListenersForCurrentDay();
    });

    function updateControls() {
      const todayKey = formatDateKey(new Date());
      if (viewMode === 'daily' && formatDateKey(viewedDate) === todayKey) {
        controlsDiv.style.display = 'block';
      } else {
        controlsDiv.style.display = 'none';
      }
    }

    async function stopCurrentActivity(atTimestamp = Date.now()) {
      if (!currentActivity) return;
      currentActivity.end = atTimestamp;
      activityLog.push(currentActivity);
      await saveDateData(viewedDate);
      currentActivity = null;
    }

    async function startActivity() {
      if (viewMode !== 'daily') return;
      if (formatDateKey(viewedDate) !== formatDateKey(new Date())) return;
      const name = activityNameInput.value.trim();
      if (!name) return;
      if (currentActivity && currentActivity.name === name) return;
      if (currentActivity) { await stopCurrentActivity(); }
      currentActivity = { name, start: Date.now() };
      activityNameInput.value = name;
      await saveDateData(viewedDate);
      updateChart();
    }

    async function stopActivity() {
      if (viewMode !== 'daily') return;
      if (!currentActivity) return;
      await stopCurrentActivity();
      activityNameInput.value = '';
      updateChart();
    }

    function selectActivity(encodedName) {
      activityNameInput.value = decodeURIComponent(encodedName);
    }

    async function deleteActivity(encodedName) {
      if (viewMode !== 'daily') return;
      const name = decodeURIComponent(encodedName);
      activityLog = activityLog.filter(a => a.name !== name);
      await saveDateData(viewedDate);
      updateChart();
    }

    function getDaysInMonth(year, month) {
      return new Date(year, month + 1, 0).getDate();
    }

    async function updateChart() {
      const labels = [];
      const dataArray = [];
      const backgroundColor = [];

      if (viewMode === 'daily') {
        const now = Date.now();
        const startOfDay = getStartOfDayTimestamp(viewedDate);
        const todayKey = formatDateKey(new Date());
        const isToday = formatDateKey(viewedDate) === todayKey;
        const totalElapsedSeconds = isToday
          ? Math.floor((now - startOfDay) / 1000)
          : SECONDS_IN_DAY;
        const elapsed = Math.min(totalElapsedSeconds, SECONDS_IN_DAY);

        const activityDurations = {};
        let productiveSeconds = 0;

        for (let a of activityLog) {
          const start = Math.max(a.start, startOfDay);
          const end = isToday
            ? Math.min(a.end || now, now)
            : Math.min(a.end, startOfDay + SECONDS_IN_DAY * 1000);
          if (end > start) {
            const dur = Math.floor((end - start) / 1000);
            activityDurations[a.name] = (activityDurations[a.name] || 0) + dur;
            productiveSeconds += dur;
          }
        }

        if (isToday && currentActivity) {
          const liveDur = Math.floor((now - currentActivity.start) / 1000);
          activityDurations[currentActivity.name] =
            (activityDurations[currentActivity.name] || 0) + liveDur;
          productiveSeconds += liveDur;
        }

        const unproductiveSeconds = Math.max(0, elapsed - productiveSeconds);
        const remainingSeconds = isToday ? Math.max(0, SECONDS_IN_DAY - elapsed) : 0;

        const baseLabels = Object.keys(activityDurations);
        const baseData = Object.values(activityDurations);

        baseLabels.forEach((name, idx) => {
          const secs = baseData[idx];
          if (showPercent) {
            const pct = ((secs / SECONDS_IN_DAY) * 100).toFixed(1);
            labels.push(`${name} (${pct}%)`);
          } else {
            labels.push(`${name} (${formatSeconds(secs)})`);
          }
          dataArray.push(secs);
        });

        if (unproductiveSeconds > 0) {
          if (showPercent) {
            const pctU = ((unproductiveSeconds / SECONDS_IN_DAY) * 100).toFixed(1);
            labels.push(`Unaccounted (${pctU}%)`);
          } else {
            labels.push(`Unaccounted (${formatSeconds(unproductiveSeconds)})`);
          }
          dataArray.push(unproductiveSeconds);
        }
        if (remainingSeconds > 0) {
          if (showPercent) {
            const pctR = ((remainingSeconds / SECONDS_IN_DAY) * 100).toFixed(1);
            labels.push(`Remaining (${pctR}%)`);
          } else {
            labels.push(`Remaining (${formatSeconds(remainingSeconds)})`);
          }
          dataArray.push(remainingSeconds);
        }

        labels.forEach(label => {
          if (label.startsWith('Unaccounted')) {
            backgroundColor.push('#777');
          } else if (label.startsWith('Remaining')) {
            backgroundColor.push('rgba(0, 0, 0, 0)');
          } else {
            const name = label.split(' (')[0];
            const idx = baseLabels.indexOf(name);
            backgroundColor.push(genericColors[idx % genericColors.length]);
          }
        });

        updateActivityStats(activityDurations, elapsed, baseLabels);

      } else {
        const year = viewedDate.getFullYear();
        const month = viewedDate.getMonth();
        const days = getDaysInMonth(year, month);
        const totalMonthSeconds = days * SECONDS_IN_DAY;
        const now = Date.now();
        const monthStart = new Date(year, month, 1).getTime();
        const isCurrentMonth =
          month === new Date().getMonth() && year === new Date().getFullYear();
        const elapsedMonthSeconds = isCurrentMonth
          ? Math.floor((now - monthStart) / 1000)
          : totalMonthSeconds;

        const dateKeys = [];
        for (let d = 1; d <= days; d++) {
          const dateObj = new Date(year, month, d);
          dateKeys.push(formatDateKey(dateObj));
        }
        const promises = dateKeys.map(key => loadFromFirestore(`logs/${key}`));
        const docs = await Promise.all(promises);

        const activityDurations = {};
        let productiveSeconds = 0;

        docs.forEach((docData, idx) => {
          const dayLog = docData?.log || [];
          const dateKey = dateKeys[idx];
          const dateParts = dateKey.split('-');
          const yearD = Number(dateParts[0]);
          const monthD = Number(dateParts[1]) - 1;
          const dayD = Number(dateParts[2]);
          const dayStart = new Date(yearD, monthD, dayD).getTime();
          const dayEnd = dayStart + SECONDS_IN_DAY * 1000;

          dayLog.forEach(a => {
            const start = a.start;
            const end =
              dateKey === formatDateKey(new Date())
                ? a.end || now
                : a.end;
            const clampedStart = Math.max(start, dayStart);
            const clampedEnd = Math.min(end, dayEnd);
            if (clampedEnd > clampedStart) {
              const dur = Math.floor((clampedEnd - clampedStart) / 1000);
              activityDurations[a.name] = (activityDurations[a.name] || 0) + dur;
              productiveSeconds += dur;
            }
          });
        });

        if (isCurrentMonth && currentActivity) {
          const liveDur = Math.floor((now - currentActivity.start) / 1000);
          activityDurations[currentActivity.name] =
            (activityDurations[currentActivity.name] || 0) + liveDur;
          productiveSeconds += liveDur;
        }

        const unproductiveSeconds = Math.max(0, elapsedMonthSeconds - productiveSeconds);
        const remainingSeconds = Math.max(0, totalMonthSeconds - elapsedMonthSeconds);

        const baseLabels = Object.keys(activityDurations);
        const baseData = Object.values(activityDurations);

        baseLabels.forEach((name, idx) => {
          const secs = baseData[idx];
          if (showPercent) {
            const pct = ((secs / totalMonthSeconds) * 100).toFixed(1);
            labels.push(`${name} (${pct}%)`);
          } else {
            labels.push(`${name} (${formatSeconds(secs)})`);
          }
          dataArray.push(secs);
        });

        if (unproductiveSeconds > 0) {
          if (showPercent) {
            const pctU = ((unproductiveSeconds / totalMonthSeconds) * 100).toFixed(1);
            labels.push(`Unaccounted (${pctU}%)`);
          } else {
            labels.push(`Unaccounted (${formatSeconds(unproductiveSeconds)})`);
          }
          dataArray.push(unproductiveSeconds);
        }
        if (remainingSeconds > 0) {
          if (showPercent) {
            const pctR = ((remainingSeconds / totalMonthSeconds) * 100).toFixed(1);
            labels.push(`Remaining (${pctR}%)`);
          } else {
            labels.push(`Remaining (${formatSeconds(remainingSeconds)})`);
          }
          dataArray.push(remainingSeconds);
        }

        labels.forEach(label => {
          if (label.startsWith('Unaccounted')) {
            backgroundColor.push('#777');
          } else if (label.startsWith('Remaining')) {
            backgroundColor.push('rgba(0, 0, 0, 0)');
          } else {
            const name = label.split(' (')[0];
            const idx = baseLabels.indexOf(name);
            backgroundColor.push(genericColors[idx % genericColors.length]);
          }
        });

        updateActivityStats(
          activityDurations,
          isCurrentMonth ? elapsedMonthSeconds : totalMonthSeconds,
          baseLabels
        );
      }

      if (chart) {
        chart.data.labels = labels;
        chart.data.datasets[0].data = dataArray;
        chart.data.datasets[0].backgroundColor = backgroundColor;
        chart.update();
      }
    }

    function updateActivityStats(durations, periodSeconds, baseLabels) {
      const statsDiv = document.getElementById('activityStats');
      let html;

      if (viewMode === 'daily') {
        html = '<table><tr><th>Activity</th><th>Time</th><th>% of Elapsed</th><th>Delete</th></tr>';
        const allLabels = Object.keys(durations);
        allLabels.forEach((name, idx) => {
          const secs = durations[name];
          const pct = ((secs / periodSeconds) * 100).toFixed(1);
          let color;
          if (name === 'Unaccounted') color = '#777';
          else {
            const ai = baseLabels.indexOf(name);
            color = genericColors[ai % genericColors.length];
          }
          html += `
            <tr>
              <td class="clickable" onclick="selectActivity('${encodeURIComponent(name)}')" style="color: ${color}">${name}</td>
              <td>${formatSeconds(secs)}</td>
              <td>${pct}%</td>
              <td><button class="delete-btn" onclick="deleteActivity('${encodeURIComponent(name)}')">&#x2716;</button></td>
            </tr>`;
        });
        html += '</table>';
      } else {
        html = '<table><tr><th>Activity</th><th>Time</th><th>% of Elapsed</th></tr>';
        const allLabels = Object.keys(durations);
        allLabels.forEach((name, idx) => {
          const secs = durations[name];
          const pct = ((secs / periodSeconds) * 100).toFixed(1);
          let color;
          if (name === 'Unaccounted') color = '#777';
          else {
            const ai = baseLabels.indexOf(name);
            color = genericColors[ai % genericColors.length];
          }
          html += `
            <tr>
              <td style="color: ${color}">${name}</td>
              <td>${formatSeconds(secs)}</td>
              <td>${pct}%</td>
            </tr>`;
        });
        html += '</table>';
      }

      statsDiv.innerHTML = html;
    }

    // ================================================
    // 4) REAL-TIME LISTENERS for current day
    // ================================================
    function setupListenersForCurrentDay() {
      const todayKey = formatDateKey(new Date());
      const logRef = db.doc(`${getUserBasePath()}/logs/${todayKey}`);
      unsubscribeLog = logRef.onSnapshot(doc => {
        const data = doc.data();
        activityLog = data?.log || [];
        updateChart();
      });
      const metaRef = db.doc(`${getUserBasePath()}/meta/currentActivity`);
      unsubscribeMeta = metaRef.onSnapshot(doc => {
        const data = doc.data();
        currentActivity = data?.currentActivity || null;
        if (currentActivity) activityNameInput.value = currentActivity.name;
        updateChart();
      });
    }

    // ================================================
    // 5) MIDNIGHT ROLLOVER (carry forward running activity)
    // ================================================
    setInterval(async () => {
      const now = Date.now();
      const today = new Date();
      const todayKey = formatDateKey(today);
      const midnightTimestamp = getStartOfDayTimestamp(today);

      if (todayKey !== lastCheckedDayKey && now >= midnightTimestamp) {
        const metaDoc = await loadFromFirestore(`meta/currentActivity`);
        const savedCurrent = metaDoc?.currentActivity || null;

        if (savedCurrent) {
          const yDay = new Date(midnightTimestamp - SECONDS_IN_DAY * 1000);
          const prevKey = formatDateKey(yDay);
          const prevLogDoc = await loadFromFirestore(`logs/${prevKey}`);
          const prevLog = prevLogDoc?.log || [];
          prevLog.push({ name: savedCurrent.name, start: savedCurrent.start, end: midnightTimestamp });
          await saveToFirestore(`logs/${prevKey}`, { log: prevLog });

          currentActivity = { name: savedCurrent.name, start: midnightTimestamp };
          await saveToFirestore(`meta/currentActivity`, { currentActivity });
        }

        viewedDate = new Date(midnightTimestamp);
        datePicker.value = new Date(midnightTimestamp).toISOString().split('T')[0];
        detachListeners();
        await loadDateData(viewedDate);
        setupListenersForCurrentDay();
        updateControls();
        updateChart();

        lastCheckedDayKey = todayKey;
      }
    }, 60 * 1000);

    // ================================================
    // 6) INITIALIZE ON PAGE LOAD
    // ================================================
    async function initializeApp() {
      const ctx = document.getElementById('timeChart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'doughnut',
        data: { labels: [], datasets: [{ data: [], backgroundColor: [], borderColor: '#eee', borderWidth: 1 }] },
        options: {
          responsive: true,
          plugins: {
            legend: { position: 'bottom' },
            tooltip: { callbacks: { label: ctx => ctx.label || '' } }
          },
          animation: false,
        }
      });

      const today = new Date();
      const offsetMinutes = today.getTimezoneOffset();
      const localMid = new Date(today.getTime() - offsetMinutes * 60000);
      const todayStr = localMid.toISOString().split('T')[0];
      const year = localMid.getFullYear();
      const month = String(localMid.getMonth() + 1).padStart(2, '0');
      const monthStr = `${year}-${month}`;

      datePicker.value = todayStr;
      monthPicker.value = monthStr;
      viewedDate = parseDateString(todayStr);

      await loadDateData(viewedDate);
      setupListenersForCurrentDay();
      updateControls();
      updateChart();

      setInterval(updateChart, 1000);
    }
  </script>
</body>
</html>
